/*
 * wrap-buddy.cc - ELF binary patcher for NixOS compatibility
 *
 * Patches dynamically-linked ELF binaries with a stub loader that:
 * 1. Loads the external loader binary
 * 2. Restores original entry point bytes
 * 3. Sets up LD_LIBRARY_PATH and loads the correct ld.so
 *
 * This preserves /proc/self/exe (important for bun, node, etc.)
 */

#include <algorithm>
#include <array>
#include <cstdint>
#include <cstring>
#include <expected>
#include <fcntl.h>
#include <filesystem>
#include <fnmatch.h>
#include <fstream>
#include <map>
#include <memory>
#include <print>
#include <ranges>
#include <set>
#include <span>
#include <string>
#include <string_view>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>
#include <variant>
#include <vector>

// Use system elf.h for structures
#include <elf.h>

// Use our config header for config file format
#include <wrap-buddy/config.h>

namespace fs = std::filesystem;

// ============================================================================
// Internal Utility Functions (defined before ElfFile for template visibility)
// ============================================================================
namespace {

// Thread-safe alternative to strerror
constexpr size_t kErrorBufferSize = 256;

auto safe_strerror(int errnum, std::array<char, kErrorBufferSize> &buffer)
    -> std::string_view {
#if defined(_GNU_SOURCE) && !defined(__APPLE__)
  // GNU-specific strerror_r returns char*
  return strerror_r(errnum, buffer.data(), buffer.size());
#else
  // POSIX strerror_r returns int and fills buffer
  if (strerror_r(errnum, buffer.data(), buffer.size()) == 0) {
    return buffer.data();
  }
  return "Unknown error";
#endif
}

// Fallback for std::start_lifetime_as (C++23 P2590R2)
// Use real implementation when available, otherwise emulate with
// reinterpret_cast
#if __cpp_lib_start_lifetime_as >= 202311L
using std::start_lifetime_as;
#else
template <typename T> auto start_lifetime_as(void *ptr) -> T * {
  static_assert(std::is_trivially_copyable_v<T>);
  // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
  return reinterpret_cast<T *>(ptr);
}

template <typename T> auto start_lifetime_as(const void *ptr) -> const T * {
  static_assert(std::is_trivially_copyable_v<T>);
  // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
  return reinterpret_cast<const T *>(ptr);
}
#endif

// Binary I/O helpers (single NOLINT point for reinterpret_cast)
template <typename T>
auto write_struct(std::ostream &out, const T &value) -> void {
  // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
  out.write(reinterpret_cast<const char *>(&value), sizeof(value));
}

auto write_bytes(std::ostream &out, std::span<const uint8_t> data) -> void {
  // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
  out.write(reinterpret_cast<const char *>(data.data()),
            static_cast<std::streamsize>(data.size()));
}

} // namespace

// Embedded stub binaries (generated by xxd -i)
// stub_64.h defines: unsigned char stub_bin[], unsigned int stub_bin_len
// stub_32.h defines: unsigned char stub32_bin[], unsigned int stub32_bin_len
#include "stub_64.h"
#ifdef HAVE_STUB_32
#include "stub_32.h"
#endif

// ============================================================================
// Types and Constants
// ============================================================================

using SonameKey = std::pair<std::string, uint16_t>; // (soname, e_machine)
using SonameEntry = std::pair<fs::path, uint8_t>;   // (directory, osabi)
using SonameCache = std::map<SonameKey, std::vector<SonameEntry>>;

struct InterpreterInfo {
  std::string path;
  uint16_t arch = 0; // e_machine
  uint8_t osabi = 0; // EI_OSABI
  std::optional<fs::path> libc_lib;
};

struct PatchConfig {
  std::vector<fs::path> runtime_deps;
  std::set<fs::path> all_lib_dirs;
};

struct Args {
  std::vector<fs::path> paths;
  std::vector<fs::path> libs;
  std::vector<fs::path> runtime_deps;
  std::vector<std::string> ignore_missing;
  std::optional<std::string> interpreter;
  bool recursive = true;
  bool dry_run = false;
};

// Result types for explicit control flow
enum class PatchResult : std::uint8_t { Skipped, Patched, MissingDeps };

struct MissingDepsError {
  fs::path binary;
  std::vector<std::string> deps;
};

// Convenience alias for void results with error
template <typename E = std::string> using Result = std::expected<void, E>;

// ============================================================================
// RAII wrapper for file descriptor (avoids manual close)
// ============================================================================

class FileDescriptor {
public:
  explicit FileDescriptor(int file_fd) : fd_(file_fd) {}
  ~FileDescriptor() {
    if (fd_ >= 0) {
      ::close(fd_);
    }
  }

  FileDescriptor(FileDescriptor &&other) noexcept : fd_(other.fd_) {
    other.fd_ = -1;
  }

  auto operator=(FileDescriptor &&other) noexcept -> FileDescriptor & {
    if (this != &other) {
      if (fd_ >= 0) {
        ::close(fd_);
      }
      fd_ = other.fd_;
      other.fd_ = -1;
    }
    return *this;
  }

  FileDescriptor(const FileDescriptor &) = delete;
  auto operator=(const FileDescriptor &) -> FileDescriptor & = delete;

  [[nodiscard]] auto get() const -> int { return fd_; }
  [[nodiscard]] auto valid() const -> bool { return fd_ >= 0; }

private:
  int fd_;
};

// ============================================================================
// RAII wrapper for mmap'd memory (avoids const_cast in munmap)
// ============================================================================

class MappedMemory {
public:
  MappedMemory(void *ptr, size_t size) : ptr_(ptr), size_(size) {}
  ~MappedMemory() {
    if (ptr_ != nullptr) {
      munmap(ptr_, size_);
    }
  }

  MappedMemory(MappedMemory &&other) noexcept
      : ptr_(other.ptr_), size_(other.size_) {
    other.ptr_ = nullptr;
    other.size_ = 0;
  }

  auto operator=(MappedMemory &&other) noexcept -> MappedMemory & {
    if (this != &other) {
      if (ptr_ != nullptr) {
        munmap(ptr_, size_);
      }
      ptr_ = other.ptr_;
      size_ = other.size_;
      other.ptr_ = nullptr;
      other.size_ = 0;
    }
    return *this;
  }

  MappedMemory(const MappedMemory &) = delete;
  auto operator=(const MappedMemory &) -> MappedMemory & = delete;

  // Factory for read-only mapping
  static auto open_readonly(const fs::path &path)
      -> std::expected<MappedMemory, std::string> {
    return open_impl(path, false);
  }

  // Factory for read-write mapping (in-place file modification)
  static auto open_readwrite(const fs::path &path)
      -> std::expected<MappedMemory, std::string> {
    return open_impl(path, true);
  }

  [[nodiscard]] auto data() const -> std::span<const uint8_t> {
    return {static_cast<const uint8_t *>(ptr_), size_};
  }

  [[nodiscard]] auto mutable_data() -> std::span<uint8_t> {
    return {static_cast<uint8_t *>(ptr_), size_};
  }

  [[nodiscard]] auto empty() const -> bool { return ptr_ == nullptr; }
  [[nodiscard]] auto size() const -> size_t { return size_; }

private:
  static auto open_impl(const fs::path &path, bool writable)
      -> std::expected<MappedMemory, std::string> {
    std::array<char, kErrorBufferSize> errbuf{};
    const FileDescriptor file(
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        ::open(path.c_str(), (writable ? O_RDWR : O_RDONLY) | O_CLOEXEC));
    if (!file.valid()) {
      return std::unexpected(std::format("cannot open '{}': {}", path.string(),
                                         safe_strerror(errno, errbuf)));
    }

    struct stat file_stat = {};
    if (fstat(file.get(), &file_stat) < 0) {
      return std::unexpected(std::format("cannot stat '{}': {}", path.string(),
                                         safe_strerror(errno, errbuf)));
    }

    const auto size = static_cast<size_t>(file_stat.st_size);
    const int prot = writable ? (PROT_READ | PROT_WRITE) : PROT_READ;
    const int flags = writable ? MAP_SHARED : MAP_PRIVATE;
    void *mapped = mmap(nullptr, size, prot, flags, file.get(), 0);
    if (mapped == MAP_FAILED) {
      return std::unexpected(std::format("cannot mmap '{}': {}", path.string(),
                                         safe_strerror(errno, errbuf)));
    }

    return MappedMemory(mapped, size);
  }

  void *ptr_;
  size_t size_;
};

// ============================================================================
// ELF Memory-Mapped File Reader
// ============================================================================

class ElfFile {
public:
  static auto open(const fs::path &path)
      -> std::expected<ElfFile, std::string> {
    auto mem_result = MappedMemory::open_readonly(path);
    if (!mem_result) {
      return std::unexpected(mem_result.error());
    }

    auto mem = std::move(*mem_result);
    if (mem.size() < EI_NIDENT) {
      return std::unexpected(
          std::format("'{}' is too small to be an ELF file", path.string()));
    }

    const auto bytes = mem.data();
    if (bytes[EI_MAG0] != ELFMAG0 || bytes[EI_MAG1] != ELFMAG1 ||
        bytes[EI_MAG2] != ELFMAG2 || bytes[EI_MAG3] != ELFMAG3) {
      return std::unexpected(
          std::format("'{}' is not an ELF file", path.string()));
    }

    // Validate ELF header and program header table bounds
    const bool is_64bit = bytes[EI_CLASS] == ELFCLASS64;
    if (is_64bit) {
      if (mem.size() < sizeof(Elf64_Ehdr)) {
        return std::unexpected(
            std::format("'{}' is too small for ELF64 header", path.string()));
      }
      const auto *ehdr = start_lifetime_as<Elf64_Ehdr>(bytes.data());
      if (ehdr->e_phoff > mem.size()) {
        return std::unexpected(
            std::format("'{}' has invalid e_phoff", path.string()));
      }
      const auto phdr_table_size =
          static_cast<uint64_t>(ehdr->e_phnum) * sizeof(Elf64_Phdr);
      if (phdr_table_size > mem.size() - ehdr->e_phoff) {
        return std::unexpected(
            std::format("'{}' program header table extends past end of file",
                        path.string()));
      }
    } else {
      if (mem.size() < sizeof(Elf32_Ehdr)) {
        return std::unexpected(
            std::format("'{}' is too small for ELF32 header", path.string()));
      }
      const auto *ehdr = start_lifetime_as<Elf32_Ehdr>(bytes.data());
      if (ehdr->e_phoff > mem.size()) {
        return std::unexpected(
            std::format("'{}' has invalid e_phoff", path.string()));
      }
      const auto phdr_table_size =
          static_cast<uint64_t>(ehdr->e_phnum) * sizeof(Elf32_Phdr);
      if (phdr_table_size > mem.size() - ehdr->e_phoff) {
        return std::unexpected(
            std::format("'{}' program header table extends past end of file",
                        path.string()));
      }
    }

    return ElfFile(std::move(mem), path);
  }

  ElfFile(ElfFile &&) noexcept = default;
  auto operator=(ElfFile &&) noexcept -> ElfFile & = default;
  ~ElfFile() = default;

  ElfFile(const ElfFile &) = delete;
  auto operator=(const ElfFile &) -> ElfFile & = delete;

  [[nodiscard]] auto data() const -> std::span<const uint8_t> {
    return mapped_.data();
  }

  [[nodiscard]] auto elf_class() const -> uint8_t { return data()[EI_CLASS]; }
  [[nodiscard]] auto osabi() const -> uint8_t { return data()[EI_OSABI]; }
  [[nodiscard]] auto is_64bit() const -> bool {
    return elf_class() == ELFCLASS64;
  }

  [[nodiscard]] auto machine() const -> uint16_t {
    if (is_64bit()) {
      return start_lifetime_as<Elf64_Ehdr>(data().data())->e_machine;
    }
    return start_lifetime_as<Elf32_Ehdr>(data().data())->e_machine;
  }

  [[nodiscard]] auto type() const -> uint16_t {
    if (is_64bit()) {
      return start_lifetime_as<Elf64_Ehdr>(data().data())->e_type;
    }
    return start_lifetime_as<Elf32_Ehdr>(data().data())->e_type;
  }

  [[nodiscard]] auto entry() const -> uint64_t {
    if (is_64bit()) {
      return start_lifetime_as<Elf64_Ehdr>(data().data())->e_entry;
    }
    return start_lifetime_as<Elf32_Ehdr>(data().data())->e_entry;
  }

  [[nodiscard]] auto path() const -> const fs::path & { return path_; }

  // Check if this is a dynamically-linked executable
  [[nodiscard]] auto is_dynamic_executable() const -> bool {
    const auto elf_type = type();
    if (elf_type != ET_EXEC && elf_type != ET_DYN) {
      return false;
    }
    return has_interp();
  }

  // Get interpreter path (PT_INTERP)
  [[nodiscard]] auto interpreter() const -> std::optional<std::string> {
    if (is_64bit()) {
      return find_interp<Elf64_Ehdr, Elf64_Phdr>();
    }
    return find_interp<Elf32_Ehdr, Elf32_Phdr>();
  }

  // Get DT_NEEDED entries
  [[nodiscard]] auto needed() const -> std::vector<std::string> {
    if (is_64bit()) {
      return find_needed<Elf64_Ehdr, Elf64_Phdr, Elf64_Dyn>();
    }
    return find_needed<Elf32_Ehdr, Elf32_Phdr, Elf32_Dyn>();
  }

  // Get RPATH/RUNPATH entries
  [[nodiscard]] auto rpath() const -> std::vector<std::string> {
    if (is_64bit()) {
      return find_rpath<Elf64_Ehdr, Elf64_Phdr, Elf64_Dyn>();
    }
    return find_rpath<Elf32_Ehdr, Elf32_Phdr, Elf32_Dyn>();
  }

private:
  ElfFile(MappedMemory mapped, fs::path path)
      : mapped_(std::move(mapped)), path_(std::move(path)) {}

  [[nodiscard]] auto has_interp() const -> bool {
    if (is_64bit()) {
      return find_interp<Elf64_Ehdr, Elf64_Phdr>().has_value();
    }
    return find_interp<Elf32_Ehdr, Elf32_Phdr>().has_value();
  }

  template <typename Ehdr, typename Phdr>
  [[nodiscard]] auto find_interp() const -> std::optional<std::string> {
    const auto *ehdr = start_lifetime_as<Ehdr>(data().data());
    const std::span<const Phdr> phdrs(
        start_lifetime_as<Phdr>(data().subspan(ehdr->e_phoff).data()),
        ehdr->e_phnum);

    for (const auto &phdr : phdrs) {
      if (phdr.p_type == PT_INTERP) {
        // Validate segment bounds
        if (phdr.p_offset > data().size() ||
            phdr.p_filesz > data().size() - phdr.p_offset) {
          return std::nullopt;
        }
        if (phdr.p_filesz == 0) {
          return std::nullopt;
        }
        // Read string within segment bounds only
        auto segment = data().subspan(phdr.p_offset, phdr.p_filesz);
        auto nul_pos = std::ranges::find(segment, uint8_t{0});
        if (nul_pos == segment.end()) {
          // No null terminator - use full segment (common for ELF)
          // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
          return std::string(reinterpret_cast<const char *>(segment.data()),
                             segment.size());
        }
        auto len = static_cast<size_t>(nul_pos - segment.begin());
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
        return std::string(reinterpret_cast<const char *>(segment.data()), len);
      }
    }
    return std::nullopt;
  }

  // Helper to access Dyn union fields with single NOLINT point
  template <typename Dyn> static auto dyn_ptr(const Dyn &dyn) -> uint64_t {
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-union-access)
    return dyn.d_un.d_ptr;
  }

  template <typename Dyn> static auto dyn_val(const Dyn &dyn) -> uint64_t {
    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-union-access)
    return dyn.d_un.d_val;
  }

  // Get string from string table with bounds checking
  static auto get_string_at(std::string_view strtab, size_t offset)
      -> std::string_view {
    if (offset >= strtab.size()) {
      return {};
    }
    // Find null terminator - string_view::substr does NOT stop at null
    const auto remaining = strtab.substr(offset);
    const auto null_pos = remaining.find('\0');
    if (null_pos == std::string_view::npos) {
      return remaining;
    }
    return remaining.substr(0, null_pos);
  }

  // Parsed dynamic section with string table
  template <typename Dyn> struct DynSection {
    std::span<const Dyn> entries;
    std::string_view strtab;
  };

  template <typename Ehdr, typename Phdr, typename Dyn>
  [[nodiscard]] auto get_dynamic_section() const
      -> std::optional<DynSection<Dyn>> {
    const auto *ehdr = start_lifetime_as<Ehdr>(data().data());
    const std::span<const Phdr> phdrs(
        start_lifetime_as<Phdr>(data().subspan(ehdr->e_phoff).data()),
        ehdr->e_phnum);

    // Find PT_DYNAMIC
    const auto dyn_phdr =
        std::ranges::find_if(phdrs, [](const auto &phdr) noexcept {
          return phdr.p_type == PT_DYNAMIC;
        });
    if (dyn_phdr == phdrs.end()) {
      return std::nullopt;
    }

    // Use p_filesz to bound the dynamic section iteration
    const auto max_entries = dyn_phdr->p_filesz / sizeof(Dyn);
    const std::span<const Dyn> entries(
        start_lifetime_as<Dyn>(data().subspan(dyn_phdr->p_offset).data()),
        max_entries);

    // Find DT_STRTAB and DT_STRSZ
    std::optional<uint64_t> strtab_vaddr;
    std::optional<size_t> strtab_size;
    for (const auto &dyn : entries) {
      if (dyn.d_tag == DT_NULL) {
        break;
      }
      if (dyn.d_tag == DT_STRTAB) {
        strtab_vaddr = dyn_ptr(dyn);
      } else if (dyn.d_tag == DT_STRSZ) {
        strtab_size = dyn_val(dyn);
      }
    }
    if (!strtab_vaddr || !strtab_size) {
      return std::nullopt;
    }
    const auto strtab =
        find_string_table<Ehdr, Phdr>(*strtab_vaddr, *strtab_size);
    if (!strtab) {
      return std::nullopt;
    }

    return DynSection<Dyn>{.entries = entries, .strtab = *strtab};
  }

  template <typename Ehdr, typename Phdr, typename Dyn>
  [[nodiscard]] auto find_needed() const -> std::vector<std::string> {
    std::vector<std::string> result;
    const auto dyn = get_dynamic_section<Ehdr, Phdr, Dyn>();
    if (!dyn) {
      return result;
    }

    for (const auto &entry : dyn->entries) {
      if (entry.d_tag == DT_NULL) {
        break;
      }
      if (entry.d_tag == DT_NEEDED) {
        const auto name = get_string_at(dyn->strtab, dyn_val(entry));
        if (!name.empty()) {
          result.emplace_back(name);
        }
      }
    }
    return result;
  }

  template <typename Ehdr, typename Phdr, typename Dyn>
  [[nodiscard]] auto find_rpath() const -> std::vector<std::string> {
    std::vector<std::string> result;
    const auto dyn = get_dynamic_section<Ehdr, Phdr, Dyn>();
    if (!dyn) {
      return result;
    }

    for (const auto &entry : dyn->entries) {
      if (entry.d_tag == DT_NULL) {
        break;
      }
      if (entry.d_tag == DT_RPATH || entry.d_tag == DT_RUNPATH) {
        const auto paths = get_string_at(dyn->strtab, dyn_val(entry));
        for (const auto part : std::views::split(paths, ':')) {
          const std::string_view path_view(part.begin(), part.end());
          if (!path_view.empty()) {
            result.emplace_back(path_view);
          }
        }
      }
    }
    return result;
  }

  template <typename Ehdr, typename Phdr>
  [[nodiscard]] auto find_string_table(uint64_t vaddr, size_t size) const
      -> std::optional<std::string_view> {
    const auto *ehdr = start_lifetime_as<Ehdr>(data().data());
    const std::span<const Phdr> phdrs(
        start_lifetime_as<Phdr>(data().subspan(ehdr->e_phoff).data()),
        ehdr->e_phnum);

    for (const auto &phdr : phdrs) {
      if (phdr.p_type == PT_LOAD) {
        if (vaddr >= phdr.p_vaddr && vaddr < phdr.p_vaddr + phdr.p_filesz) {
          const auto offset = phdr.p_offset + (vaddr - phdr.p_vaddr);
          return std::string_view(
              start_lifetime_as<char>(data().subspan(offset).data()), size);
        }
      }
    }
    return std::nullopt;
  }

  MappedMemory mapped_;
  fs::path path_;
};

// ============================================================================
// Utility Functions
// ============================================================================

namespace {

auto is_elf_file(const fs::path &path) -> bool {
  std::ifstream file(path, std::ios::binary);
  if (!file) {
    return false;
  }
  std::array<char, 4> magic{};
  file.read(magic.data(), magic.size());
  return file.gcount() == 4 && magic[0] == ELFMAG0 && magic[1] == ELFMAG1 &&
         magic[2] == ELFMAG2 && magic[3] == ELFMAG3;
}

auto is_shared_library(const fs::path &path) -> bool {
  const auto name = path.filename().string();
  return name.ends_with(".so") || name.contains(".so.");
}

auto osabi_compatible(uint8_t osabi_a, uint8_t osabi_b) -> bool {
  // ELFOSABI_SYSV (0) is compatible with everything
  return osabi_a == ELFOSABI_SYSV || osabi_b == ELFOSABI_SYSV ||
         osabi_a == osabi_b;
}

auto expand_origin(std::string_view rpath, const fs::path &origin)
    -> std::string {
  constexpr std::string_view kOriginMarker = "$ORIGIN";
  std::string result(rpath);
  size_t pos = 0;
  while ((pos = result.find(kOriginMarker)) != std::string::npos) {
    result.replace(pos, kOriginMarker.size(), origin.string());
  }
  return result;
}

// ============================================================================
// Soname Cache
// ============================================================================

auto process_library(const fs::path &lib_path, SonameCache &cache,
                     std::set<fs::path> &lib_dirs,
                     std::vector<fs::path> &rpath_queue) -> void {
  auto elf_result = ElfFile::open(lib_path);
  if (!elf_result) {
    return;
  }

  std::error_code err;
  const auto resolved = fs::canonical(lib_path, err);
  if (err) {
    return;
  }

  auto &elf = *elf_result;
  const auto lib_dir = resolved.parent_path();

  cache[{lib_path.filename().string(), elf.machine()}].emplace_back(
      lib_dir, elf.osabi());
  lib_dirs.insert(lib_dir);

  // Queue RPATH directories for transitive scanning
  for (const auto &rpath : elf.rpath()) {
    const auto expanded = expand_origin(rpath, lib_dir);
    if (fs::exists(expanded, err) && !err) {
      rpath_queue.emplace_back(expanded);
    }
  }
}

template <typename DirIterator>
auto scan_directory(const fs::path &dir_path, SonameCache &cache,
                    std::set<fs::path> &lib_dirs, std::vector<fs::path> &queue)
    -> void {
  std::error_code err;
  for (auto iter = DirIterator(dir_path, err); iter != DirIterator() && !err;
       iter.increment(err)) {
    if (!iter->is_regular_file(err) || err) {
      continue;
    }
    const auto &path = iter->path();
    if (is_shared_library(path) && is_elf_file(path)) {
      process_library(path, cache, lib_dirs, queue);
    }
  }
}

auto populate_cache(SonameCache &cache, const std::vector<fs::path> &paths,
                    std::set<fs::path> &lib_dirs, bool recursive) -> void {
  std::set<fs::path> visited;
  std::vector<fs::path> queue = paths;
  std::error_code err;

  while (!queue.empty()) {
    auto current_path = std::move(queue.back());
    queue.pop_back();

    if (!fs::exists(current_path, err) || err) {
      continue;
    }

    auto canonical_path = fs::canonical(current_path, err);
    if (err || visited.contains(canonical_path)) {
      continue;
    }
    visited.insert(canonical_path);

    if (fs::is_regular_file(current_path, err) && !err) {
      if (is_shared_library(current_path) && is_elf_file(current_path)) {
        process_library(current_path, cache, lib_dirs, queue);
      }
    } else if (fs::is_directory(current_path, err) && !err) {
      if (recursive) {
        scan_directory<fs::recursive_directory_iterator>(current_path, cache,
                                                         lib_dirs, queue);
      } else {
        scan_directory<fs::directory_iterator>(current_path, cache, lib_dirs,
                                               queue);
      }
    }
  }
}

auto find_dependency(const SonameCache &cache, const std::string &soname,
                     uint16_t arch, uint8_t osabi) -> std::optional<fs::path> {
  auto iter = cache.find({soname, arch});
  if (iter == cache.end()) {
    return std::nullopt;
  }

  for (const auto &[dir, lib_osabi] : iter->second) {
    if (osabi_compatible(osabi, lib_osabi)) {
      return dir;
    }
  }
  return std::nullopt;
}

// ============================================================================
// Binary Patching
// ============================================================================

auto get_stub(bool is_64bit) -> std::span<const uint8_t> {
  if (is_64bit) {
#if defined(__x86_64__) || defined(__aarch64__)
    // On 64-bit platforms, stub_bin is 64-bit
    return std::span<const uint8_t>{stub_bin};
#else
    // On 32-bit platforms, we can't patch 64-bit binaries
    return {};
#endif
  }
  // Requesting 32-bit stub
#ifdef HAVE_STUB_32
  // On x86_64 with multilib support, use the separate 32-bit stub
  return std::span<const uint8_t>{stub32_bin};
#elifdef __i386__
  // On native i386, stub_bin IS the 32-bit stub
  return std::span<const uint8_t>{stub_bin};
#else
  return {};
#endif
}

struct EntryInfo {
  uint64_t file_offset = 0;
  uint64_t available_space = 0;
};

// Validate ELF header and program header table bounds
template <typename Ehdr, typename Phdr>
auto validate_elf_bounds(std::span<const uint8_t> data)
    -> std::expected<void, std::string> {
  if (data.size() < sizeof(Ehdr)) {
    return std::unexpected("file too small for ELF header");
  }
  const auto *ehdr = start_lifetime_as<Ehdr>(data.data());

  // Check program header table offset
  if (ehdr->e_phoff > data.size()) {
    return std::unexpected("e_phoff points outside file");
  }

  // Check program header table fits in file (check for overflow too)
  const auto phdr_table_size =
      static_cast<uint64_t>(ehdr->e_phnum) * sizeof(Phdr);
  if (phdr_table_size > data.size() - ehdr->e_phoff) {
    return std::unexpected("program header table extends past end of file");
  }

  return {};
}

template <typename Ehdr, typename Phdr>
auto find_entry_segment(std::span<const uint8_t> data, uint64_t entry_vaddr)
    -> std::optional<EntryInfo> {
  // Caller must validate ELF bounds first
  const auto *ehdr = start_lifetime_as<Ehdr>(data.data());
  const std::span<const Phdr> phdrs(
      start_lifetime_as<Phdr>(data.subspan(ehdr->e_phoff).data()),
      ehdr->e_phnum);

  for (size_t idx = 0; idx < phdrs.size(); ++idx) {
    const auto &phdr = phdrs[idx];
    if (phdr.p_type == PT_LOAD && entry_vaddr >= phdr.p_vaddr &&
        entry_vaddr < phdr.p_vaddr + phdr.p_filesz) {
      const auto file_offset = phdr.p_offset + (entry_vaddr - phdr.p_vaddr);
      const auto available_space = phdr.p_filesz - (entry_vaddr - phdr.p_vaddr);
      // Validate segment is within file bounds
      if (file_offset > data.size() ||
          available_space > data.size() - file_offset) {
        return std::nullopt;
      }
      return EntryInfo{.file_offset = file_offset,
                       .available_space = available_space};
    }
  }
  return std::nullopt;
}

template <typename Ehdr, typename Phdr>
auto find_interp_phdr_offset(std::span<const uint8_t> data)
    -> std::optional<uint64_t> {
  // Caller must validate ELF bounds first; write site validates offset
  const auto *ehdr = start_lifetime_as<Ehdr>(data.data());
  const std::span<const Phdr> phdrs(
      start_lifetime_as<Phdr>(data.subspan(ehdr->e_phoff).data()),
      ehdr->e_phnum);

  for (size_t idx = 0; idx < phdrs.size(); ++idx) {
    if (phdrs[idx].p_type == PT_INTERP) {
      return ehdr->e_phoff + (idx * sizeof(Phdr));
    }
  }
  return std::nullopt;
}

auto write_config_file(const fs::path &config_path, bool is_64bit,
                       uint64_t orig_entry, size_t padded_size,
                       const std::string &interp_path, const std::string &rpath,
                       std::span<const uint8_t> orig_bytes) -> Result<> {
  std::ofstream config(config_path, std::ios::binary);
  if (!config) {
    return std::unexpected(std::format(
        "cannot write config file '{}' (check directory permissions)",
        config_path.string()));
  }

  auto interp_len = static_cast<uint16_t>(interp_path.size() + 1);
  auto rpath_len = static_cast<uint16_t>(rpath.size() + 1);

  if (is_64bit) {
    const Config64 hdr{.orig_entry = orig_entry,
                       .stub_size = padded_size,
                       .interp_len = interp_len,
                       .rpath_len = rpath_len};
    write_struct(config, hdr);
  } else {
    const Config32 hdr{.orig_entry = static_cast<uint32_t>(orig_entry),
                       .stub_size = static_cast<uint32_t>(padded_size),
                       .interp_len = interp_len,
                       .rpath_len = rpath_len};
    write_struct(config, hdr);
  }

  config.write(interp_path.c_str(), static_cast<std::streamsize>(interp_len));
  config.write(rpath.c_str(), static_cast<std::streamsize>(rpath_len));
  write_bytes(config, orig_bytes);

  std::error_code perm_ec;
  fs::permissions(config_path,
                  fs::perms::owner_read | fs::perms::owner_write |
                      fs::perms::group_read | fs::perms::others_read,
                  perm_ec);
  if (perm_ec) {
    std::println(stderr, "Warning: failed to set permissions on {}: {}",
                 config_path.string(), perm_ec.message());
  }
  return {};
}

auto patch_binary(const fs::path &binary_path, const std::string &interp_path,
                  const std::string &rpath, bool dry_run) -> Result<> {
  // Memory-map file for in-place modification
  auto mem_result = MappedMemory::open_readwrite(binary_path);
  if (!mem_result) {
    return std::unexpected(mem_result.error());
  }

  auto &mem = *mem_result;
  if (mem.size() < EI_NIDENT) {
    return std::unexpected(std::format("'{}' is too small to be a valid ELF",
                                       binary_path.string()));
  }

  const auto data = mem.data();
  const bool is_64bit = data[EI_CLASS] == ELFCLASS64;

  // Validate ELF structure before accessing headers
  if (is_64bit) {
    if (auto err = validate_elf_bounds<Elf64_Ehdr, Elf64_Phdr>(data); !err) {
      return std::unexpected(err.error());
    }
  } else {
    if (auto err = validate_elf_bounds<Elf32_Ehdr, Elf32_Phdr>(data); !err) {
      return std::unexpected(err.error());
    }
  }

  auto stub = get_stub(is_64bit);
  if (stub.empty()) {
    return std::unexpected(
        std::format("no {}-bit stub available", is_64bit ? "64" : "32"));
  }

  uint64_t orig_entry = 0;
  std::optional<EntryInfo> entry_info;

  if (is_64bit) {
    orig_entry = start_lifetime_as<Elf64_Ehdr>(data.data())->e_entry;
    entry_info = find_entry_segment<Elf64_Ehdr, Elf64_Phdr>(data, orig_entry);
  } else {
    orig_entry = start_lifetime_as<Elf32_Ehdr>(data.data())->e_entry;
    entry_info = find_entry_segment<Elf32_Ehdr, Elf32_Phdr>(data, orig_entry);
  }

  if (!entry_info) {
    return std::unexpected("entry point is not within a loadable segment");
  }

  std::println("  ELF class: {}", is_64bit ? "64-bit" : "32-bit");
  std::println("  Original entry: {:#x} (file offset: {:#x})", orig_entry,
               entry_info->file_offset);
  std::println("  Available space at entry: {} bytes",
               entry_info->available_space);
  // Round up for 16-byte alignment
  constexpr size_t kStubAlignment = 16;
  const size_t padded_size =
      (stub.size() + kStubAlignment - 1) & ~(kStubAlignment - 1);

  std::println("  Stub size: {} bytes (padded to {})", stub.size(),
               padded_size);

  if (padded_size > entry_info->available_space) {
    return std::unexpected(std::format(
        "not enough space at entry point ({} bytes needed, {} available)",
        padded_size, entry_info->available_space));
  }

  if (dry_run) {
    std::println("  [dry-run] Would patch binary");
    return {};
  }

  // Save original bytes for config file
  const auto file_offset = entry_info->file_offset;
  if (file_offset + padded_size > data.size()) {
    return std::unexpected("entry point region extends past end of file");
  }
  std::vector<uint8_t> orig_bytes(
      data.begin() + static_cast<std::ptrdiff_t>(file_offset),
      data.begin() + static_cast<std::ptrdiff_t>(file_offset + padded_size));

  // Write config file
  auto config_path = binary_path.parent_path() /
                     ("." + binary_path.filename().string() + ".wrapbuddy");

  if (auto err = write_config_file(config_path, is_64bit, orig_entry,
                                   padded_size, interp_path, rpath, orig_bytes);
      !err) {
    return std::unexpected(err.error());
  }
  std::println("  Wrote config to {}", config_path.string());

  // Get mutable view for in-place patching
  auto mutable_data = mem.mutable_data();

  // Overwrite entry point with stub (padded)
  std::ranges::copy(stub, mutable_data.begin() +
                              static_cast<std::ptrdiff_t>(file_offset));
  std::ranges::fill(mutable_data.begin() +
                        static_cast<std::ptrdiff_t>(file_offset + stub.size()),
                    mutable_data.begin() +
                        static_cast<std::ptrdiff_t>(file_offset + padded_size),
                    uint8_t{0});
  std::println("  Overwrote {} bytes at entry point", padded_size);

  // Convert PT_INTERP to PT_NULL
  std::optional<uint64_t> interp_offset;
  if (is_64bit) {
    interp_offset = find_interp_phdr_offset<Elf64_Ehdr, Elf64_Phdr>(data);
  } else {
    interp_offset = find_interp_phdr_offset<Elf32_Ehdr, Elf32_Phdr>(data);
  }

  if (interp_offset) {
    if (*interp_offset + sizeof(uint32_t) > mutable_data.size()) {
      return std::unexpected("PT_INTERP offset is outside file bounds");
    }
    // p_type is always first field and always 4 bytes
    *start_lifetime_as<uint32_t>(mutable_data.subspan(*interp_offset).data()) =
        PT_NULL;
    std::println("  Converted PT_INTERP to PT_NULL");
  }

  // MappedMemory destructor calls munmap; kernel flushes MAP_SHARED pages
  return {};
}

// ============================================================================
// Dependency Resolution
// ============================================================================

auto resolve_dependency(const std::string &dep, const SonameCache &cache,
                        const std::optional<fs::path> &libc_lib,
                        const std::vector<std::string> &existing_rpath,
                        const fs::path &binary_dir, uint16_t arch,
                        uint8_t osabi) -> std::optional<fs::path> {
  std::error_code err_code;

  // Check libc lib first
  if (libc_lib && fs::exists(*libc_lib / dep, err_code) && !err_code) {
    return libc_lib;
  }

  // Check existing RPATH
  for (const auto &rpath : existing_rpath) {
    auto expanded = expand_origin(rpath, binary_dir);
    if (fs::exists(fs::path(expanded) / dep, err_code) && !err_code) {
      return expanded;
    }
  }

  // Check cache
  return find_dependency(cache, dep, arch, osabi);
}

auto build_rpath(const std::set<fs::path> &library_dirs,
                 const std::vector<fs::path> &runtime_deps,
                 const std::set<fs::path> &all_lib_dirs,
                 const std::optional<fs::path> &libc_lib,
                 const std::vector<std::string> &existing_rpath)
    -> std::string {
  std::set<fs::path> combined = all_lib_dirs;
  combined.insert(library_dirs.begin(), library_dirs.end());
  std::error_code err_code;

  // Preserve existing Nix store RPATH entries
  for (const auto &rpath : existing_rpath) {
    if (rpath.starts_with("/nix/store/") && fs::exists(rpath, err_code) &&
        !err_code) {
      combined.insert(rpath);
    }
  }

  // Add runtime deps
  for (const auto &dep : runtime_deps) {
    if (fs::exists(dep, err_code) && !err_code) {
      combined.insert(dep);
    }
  }

  std::string result;
  for (const auto &dir : combined) {
    if (!result.empty()) {
      result += ':';
    }
    result += dir.string();
  }

  if (libc_lib) {
    if (!result.empty()) {
      result += ':';
    }
    result += libc_lib->string();
  }

  return result;
}

// Error type that can be either a string or missing deps
using ProcessError = std::variant<std::string, MissingDepsError>;

auto process_binary(const fs::path &binary_path, const SonameCache &cache,
                    const InterpreterInfo &interp_info,
                    const std::vector<std::string> &ignore_missing,
                    const PatchConfig &config, bool dry_run)
    -> std::expected<PatchResult, ProcessError> {

  auto elf_result = ElfFile::open(binary_path);
  if (!elf_result) {
    return std::unexpected(ProcessError{elf_result.error()});
  }

  auto &elf = *elf_result;

  // Skip non-dynamic executables
  if (!elf.is_dynamic_executable()) {
    return PatchResult::Skipped;
  }

  // Skip if already has Nix store interpreter
  auto current_interp = elf.interpreter();
  if (current_interp && current_interp->starts_with("/nix/store/")) {
    return PatchResult::Skipped;
  }

  // Skip if arch doesn't match
  if (elf.machine() != interp_info.arch) {
    return PatchResult::Skipped;
  }

  // Skip if OSABI incompatible
  if (!osabi_compatible(elf.osabi(), interp_info.osabi)) {
    return PatchResult::Skipped;
  }

  auto deps = elf.needed();
  auto existing_rpath = elf.rpath();
  auto binary_dir = binary_path.parent_path();

  std::set<fs::path> library_dirs;
  std::vector<std::string> missing;

  for (const auto &dep : deps) {
    auto lib_dir =
        resolve_dependency(dep, cache, interp_info.libc_lib, existing_rpath,
                           binary_dir, elf.machine(), elf.osabi());
    if (lib_dir) {
      library_dirs.insert(*lib_dir);
    } else {
      bool ignored = false;
      for (const auto &pattern : ignore_missing) {
        if (fnmatch(pattern.c_str(), dep.c_str(), 0) == 0) {
          ignored = true;
          break;
        }
      }
      if (!ignored) {
        missing.push_back(dep);
      }
    }
  }

  if (!missing.empty()) {
    return std::unexpected(ProcessError{
        MissingDepsError{.binary = binary_path, .deps = std::move(missing)}});
  }

  auto rpath =
      build_rpath(library_dirs, config.runtime_deps, config.all_lib_dirs,
                  interp_info.libc_lib, existing_rpath);

  std::println("Patching: {}", binary_path.string());

  auto patch_result =
      patch_binary(binary_path, interp_info.path, rpath, dry_run);
  if (!patch_result) {
    return std::unexpected(ProcessError{patch_result.error()});
  }

  std::println("Patched: {}", binary_path.string());
  return PatchResult::Patched;
}

// ============================================================================
// Interpreter Info
// ============================================================================

auto get_interpreter_info(const std::string &path,
                          std::optional<fs::path> libc_lib = std::nullopt)
    -> std::expected<InterpreterInfo, std::string> {
  auto elf_result = ElfFile::open(path);
  if (!elf_result) {
    return std::unexpected(elf_result.error());
  }

  return InterpreterInfo{.path = path,
                         .arch = elf_result->machine(),
                         .osabi = elf_result->osabi(),
                         .libc_lib = std::move(libc_lib)};
}

// ============================================================================
// Main
// ============================================================================

// Built-in defaults (set via -D flags in Makefile)
#ifndef DEFAULT_INTERP
#define DEFAULT_INTERP nullptr
#endif

#ifndef DEFAULT_LIBC_LIB
#define DEFAULT_LIBC_LIB nullptr
#endif

auto usage(std::string_view progname) -> void {
  std::println(stderr, "Usage: {} [options]", progname);
  std::println(stderr, "Options:");
  std::println(stderr,
               "  --paths PATH...          Paths to scan for executables");
  std::println(stderr,
               "  --libs PATH...           Library directories to search");
  std::println(stderr, "  --runtime-dependencies PATH...");
  std::println(stderr, "                           Runtime dependency paths");
  std::println(stderr, "  --ignore-missing PATTERN...");
  std::println(
      stderr,
      "                           Patterns for deps to ignore if missing");
  std::println(stderr,
               "  --no-recurse             Don't recurse into subdirectories");
  std::println(stderr, "  --dry-run                Show what would be done");
  std::println(stderr, "  --interpreter PATH       Path to dynamic linker");
  std::println(stderr, "  --help                   Show this help");
}

struct HelpRequested {};
using ParseError = std::variant<std::string, HelpRequested>;

auto parse_args(std::span<char *> argv_span)
    -> std::expected<Args, ParseError> {
  Args args;
  size_t idx = 1; // Skip program name

  // Collect non-option arguments until next option or end
  auto collect_args = [&](auto &vec) -> void {
    while (idx < argv_span.size()) {
      const std::string_view arg(argv_span[idx]);
      if (arg.starts_with('-')) {
        break;
      }
      vec.emplace_back(arg);
      ++idx;
    }
  };

  while (idx < argv_span.size()) {
    const std::string_view arg(argv_span[idx]);
    ++idx;

    if (arg == "--paths") {
      collect_args(args.paths);
    } else if (arg == "--libs") {
      collect_args(args.libs);
    } else if (arg == "--runtime-dependencies") {
      collect_args(args.runtime_deps);
    } else if (arg == "--ignore-missing") {
      collect_args(args.ignore_missing);
    } else if (arg == "--no-recurse") {
      args.recursive = false;
    } else if (arg == "--dry-run") {
      args.dry_run = true;
    } else if (arg == "--interpreter") {
      if (idx >= argv_span.size()) {
        return std::unexpected(
            ParseError{"--interpreter requires an argument"});
      }
      args.interpreter = argv_span[idx];
      ++idx;
    } else if (arg == "--help" || arg == "-h") {
      return std::unexpected(ParseError{HelpRequested{}});
    } else if (arg.starts_with('-')) {
      return std::unexpected(
          ParseError{std::format("unknown option: {}", arg)});
    } else {
      return std::unexpected(
          ParseError{std::format("unexpected argument: {}", arg)});
    }
  }

  if (args.paths.empty()) {
    return std::unexpected(ParseError{"--paths is required"});
  }

  return args;
}

template <typename Callback>
auto process_path_entry(const fs::path &path, bool recursive,
                        Callback &&callback) -> void {
  auto invoke = std::forward<Callback>(callback);
  std::error_code err;
  if (!fs::exists(path, err) || err || fs::is_symlink(path, err) || err) {
    return;
  }

  if (fs::is_regular_file(path, err) && !err) {
    invoke(path);
    return;
  }

  if (!fs::is_directory(path, err) || err) {
    return;
  }

  if (recursive) {
    for (auto iter = fs::recursive_directory_iterator(path, err);
         iter != fs::recursive_directory_iterator() && !err;
         iter.increment(err)) {
      if (!iter->is_symlink(err) && !err && iter->is_regular_file(err) &&
          !err) {
        invoke(iter->path());
      }
    }
  } else {
    for (auto iter = fs::directory_iterator(path, err);
         iter != fs::directory_iterator() && !err; iter.increment(err)) {
      if (!iter->is_symlink(err) && !err && iter->is_regular_file(err) &&
          !err) {
        invoke(iter->path());
      }
    }
  }
}

auto report_errors(const std::vector<std::string> &errors,
                   const std::vector<MissingDepsError> &all_missing) -> void {
  for (const auto &err : errors) {
    std::println(stderr, "error: {}", err);
  }

  if (!all_missing.empty()) {
    std::println(stderr, "\nerror: missing dependencies");
    std::println(
        stderr,
        "       add library paths with --libs or use --ignore-missing\n");
    for (const auto &missing : all_missing) {
      std::println(stderr, "{}:", missing.binary.string());
      for (const auto &dep : missing.deps) {
        std::println(stderr, "  {}", dep);
      }
    }
  }
}

auto run_patcher(const Args &args, const InterpreterInfo &interp_info) -> int {
  // Build soname cache
  SonameCache cache;
  std::set<fs::path> discovered_lib_dirs;

  populate_cache(cache, args.paths, discovered_lib_dirs, args.recursive);
  populate_cache(cache, args.libs, discovered_lib_dirs, false);
  populate_cache(cache, args.runtime_deps, discovered_lib_dirs, false);

  const PatchConfig config{.runtime_deps = args.runtime_deps,
                           .all_lib_dirs = discovered_lib_dirs};

  std::vector<MissingDepsError> all_missing;
  std::vector<std::string> errors;

  auto process_file = [&](const fs::path &path) -> void {
    if (!is_elf_file(path)) {
      return;
    }

    auto result = process_binary(path, cache, interp_info, args.ignore_missing,
                                 config, args.dry_run);
    if (!result) {
      std::visit(
          [&](auto &&error) -> void {
            using T = std::decay_t<decltype(error)>;
            if constexpr (std::is_same_v<T, MissingDepsError>) {
              all_missing.push_back(std::forward<decltype(error)>(error));
            } else {
              errors.push_back(std::format("{}: {}", path.string(), error));
            }
          },
          result.error());
    }
  };

  for (const auto &path : args.paths) {
    process_path_entry(path, args.recursive, process_file);
  }

  report_errors(errors, all_missing);
  return (errors.empty() && all_missing.empty()) ? 0 : 1;
}

} // namespace

auto main(int argc, char *argv[]) -> int {
  try {
    const std::span<char *> argv_span(argv, static_cast<size_t>(argc));
    const std::string_view progname = argc > 0 ? argv_span[0] : "wrap-buddy";

    auto args_result = parse_args(argv_span);
    if (!args_result) {
      return std::visit(
          [&](auto &&err) -> int {
            using T = std::decay_t<decltype(err)>;
            if constexpr (std::is_same_v<T, HelpRequested>) {
              usage(progname);
              return 0;
            } else {
              std::println(stderr, "error: {}", err);
              usage(progname);
              return 1;
            }
          },
          args_result.error());
    }
    const auto &args = *args_result;

    std::expected<InterpreterInfo, std::string> interp_result;
    if (args.interpreter) {
      interp_result = get_interpreter_info(*args.interpreter);
    } else if constexpr (DEFAULT_INTERP != nullptr) {
      std::optional<fs::path> libc_lib;
      if constexpr (DEFAULT_LIBC_LIB != nullptr) {
        libc_lib = DEFAULT_LIBC_LIB;
      }
      interp_result = get_interpreter_info(DEFAULT_INTERP, libc_lib);
    } else {
      std::println(
          stderr,
          "error: no interpreter specified\n"
          "       use --interpreter to specify the dynamic linker path");
      return 1;
    }

    if (!interp_result) {
      std::println(stderr, "error: {}", interp_result.error());
      return 1;
    }

    const auto &interp_info = *interp_result;
    std::println("Using interpreter: {}", interp_info.path);

    auto stub_64 = get_stub(true);
    if (!stub_64.empty()) {
      std::println("64-bit stub: {} bytes", stub_64.size());
    } else {
      std::println("64-bit stub: not available");
    }

    auto stub_32 = get_stub(false);
    if (!stub_32.empty()) {
      std::println("32-bit stub: {} bytes", stub_32.size());
    } else {
      std::println("32-bit stub: not available");
    }

    return run_patcher(args, interp_info);
  } catch (const std::exception &ex) {
    // Use fputs in catch handler - std::println can throw
    // Explicitly discard return values - nothing we can do if error output
    // fails
    static_cast<void>(std::fputs("fatal error: ", stderr));
    static_cast<void>(std::fputs(ex.what(), stderr));
    static_cast<void>(std::fputc('\n', stderr));
    return 1;
  }
}
