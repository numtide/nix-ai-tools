/*
 * patcher.h - Binary patching logic
 */

#pragma once

#include "io.h"
#include "mapped_memory.h"

#include <algorithm>
#include <cstdint>
#include <elf.h>
#include <expected>
#include <filesystem>
#include <format>
#include <fstream>
#include <print>
#include <span>
#include <string>
#include <vector>

#include <wrap-buddy/config.h>

// Embedded stub binaries (generated by xxd -i)
#include "stub_64.h"
#ifdef HAVE_STUB_32
#include "stub_32.h"
#endif

namespace wrap_buddy {

namespace fs = std::filesystem;

// Convenience alias for void results with error
template <typename E = std::string> using Result = std::expected<void, E>;

inline auto get_stub(bool is_64bit) -> std::span<const uint8_t> {
  if (is_64bit) {
#if defined(__x86_64__) || defined(__aarch64__)
    // On 64-bit platforms, stub_bin is 64-bit
    return std::span<const uint8_t>{stub_bin};
#else
    // On 32-bit platforms, we can't patch 64-bit binaries
    return {};
#endif
  }
  // Requesting 32-bit stub
#ifdef HAVE_STUB_32
  // On x86_64 with multilib support, use the separate 32-bit stub
  return std::span<const uint8_t>{stub32_bin};
#elifdef __i386__
  // On native i386, stub_bin IS the 32-bit stub
  return std::span<const uint8_t>{stub_bin};
#else
  return {};
#endif
}

struct EntryInfo {
  uint64_t file_offset = 0;
  uint64_t available_space = 0;
};

// Validate ELF header and program header table bounds
template <typename Ehdr, typename Phdr>
auto validate_elf_bounds(std::span<const uint8_t> data)
    -> std::expected<void, std::string> {
  if (data.size() < sizeof(Ehdr)) {
    return std::unexpected("file too small for ELF header");
  }
  const auto *ehdr = start_lifetime_as<Ehdr>(data.data());

  // Check program header table offset
  if (ehdr->e_phoff > data.size()) {
    return std::unexpected("e_phoff points outside file");
  }

  // Check program header table fits in file (check for overflow too)
  const auto phdr_table_size =
      static_cast<uint64_t>(ehdr->e_phnum) * sizeof(Phdr);
  if (phdr_table_size > data.size() - ehdr->e_phoff) {
    return std::unexpected("program header table extends past end of file");
  }

  return {};
}

template <typename Ehdr, typename Phdr>
auto find_entry_segment(std::span<const uint8_t> data, uint64_t entry_vaddr)
    -> std::optional<EntryInfo> {
  // Caller must validate ELF bounds first
  const auto *ehdr = start_lifetime_as<Ehdr>(data.data());
  const std::span<const Phdr> phdrs(
      start_lifetime_as<Phdr>(data.subspan(ehdr->e_phoff).data()),
      ehdr->e_phnum);

  for (size_t idx = 0; idx < phdrs.size(); ++idx) {
    const auto &phdr = phdrs[idx];
    if (phdr.p_type == PT_LOAD && entry_vaddr >= phdr.p_vaddr &&
        entry_vaddr < phdr.p_vaddr + phdr.p_filesz) {
      const auto file_offset = phdr.p_offset + (entry_vaddr - phdr.p_vaddr);
      const auto available_space = phdr.p_filesz - (entry_vaddr - phdr.p_vaddr);
      // Validate segment is within file bounds
      if (file_offset > data.size() ||
          available_space > data.size() - file_offset) {
        return std::nullopt;
      }
      return EntryInfo{.file_offset = file_offset,
                       .available_space = available_space};
    }
  }
  return std::nullopt;
}

template <typename Ehdr, typename Phdr>
auto find_interp_phdr_offset(std::span<const uint8_t> data)
    -> std::optional<uint64_t> {
  // Caller must validate ELF bounds first; write site validates offset
  const auto *ehdr = start_lifetime_as<Ehdr>(data.data());
  const std::span<const Phdr> phdrs(
      start_lifetime_as<Phdr>(data.subspan(ehdr->e_phoff).data()),
      ehdr->e_phnum);

  for (size_t idx = 0; idx < phdrs.size(); ++idx) {
    if (phdrs[idx].p_type == PT_INTERP) {
      return ehdr->e_phoff + (idx * sizeof(Phdr));
    }
  }
  return std::nullopt;
}

inline auto write_config_file(const fs::path &config_path, bool is_64bit,
                              uint64_t orig_entry, size_t padded_size,
                              const std::string &interp_path,
                              const std::string &rpath,
                              std::span<const uint8_t> orig_bytes) -> Result<> {
  std::ofstream config(config_path, std::ios::binary);
  if (!config) {
    return std::unexpected(std::format(
        "cannot write config file '{}' (check directory permissions)",
        config_path.string()));
  }

  auto interp_len = static_cast<uint16_t>(interp_path.size() + 1);
  auto rpath_len = static_cast<uint16_t>(rpath.size() + 1);

  if (is_64bit) {
    const Config64 hdr{.orig_entry = orig_entry,
                       .stub_size = padded_size,
                       .interp_len = interp_len,
                       .rpath_len = rpath_len};
    write_struct(config, hdr);
  } else {
    const Config32 hdr{.orig_entry = static_cast<uint32_t>(orig_entry),
                       .stub_size = static_cast<uint32_t>(padded_size),
                       .interp_len = interp_len,
                       .rpath_len = rpath_len};
    write_struct(config, hdr);
  }

  config.write(interp_path.c_str(), static_cast<std::streamsize>(interp_len));
  config.write(rpath.c_str(), static_cast<std::streamsize>(rpath_len));
  write_bytes(config, orig_bytes);

  std::error_code perm_ec;
  fs::permissions(config_path,
                  fs::perms::owner_read | fs::perms::owner_write |
                      fs::perms::group_read | fs::perms::others_read,
                  perm_ec);
  if (perm_ec) {
    std::println(stderr, "Warning: failed to set permissions on {}: {}",
                 config_path.string(), perm_ec.message());
  }
  return {};
}

inline auto patch_binary(const fs::path &binary_path,
                         const std::string &interp_path,
                         const std::string &rpath, bool dry_run) -> Result<> {
  // Memory-map file for in-place modification
  auto mem_result = MappedMemory::open_readwrite(binary_path);
  if (!mem_result) {
    return std::unexpected(mem_result.error());
  }

  auto &mem = *mem_result;
  if (mem.size() < EI_NIDENT) {
    return std::unexpected(std::format("'{}' is too small to be a valid ELF",
                                       binary_path.string()));
  }

  const auto data = mem.data();
  const bool is_64bit = data[EI_CLASS] == ELFCLASS64;

  // Validate ELF structure before accessing headers
  if (is_64bit) {
    if (auto err = validate_elf_bounds<Elf64_Ehdr, Elf64_Phdr>(data); !err) {
      return std::unexpected(err.error());
    }
  } else {
    if (auto err = validate_elf_bounds<Elf32_Ehdr, Elf32_Phdr>(data); !err) {
      return std::unexpected(err.error());
    }
  }

  auto stub = get_stub(is_64bit);
  if (stub.empty()) {
    return std::unexpected(
        std::format("no {}-bit stub available", is_64bit ? "64" : "32"));
  }

  uint64_t orig_entry = 0;
  std::optional<EntryInfo> entry_info;

  if (is_64bit) {
    orig_entry = start_lifetime_as<Elf64_Ehdr>(data.data())->e_entry;
    entry_info = find_entry_segment<Elf64_Ehdr, Elf64_Phdr>(data, orig_entry);
  } else {
    orig_entry = start_lifetime_as<Elf32_Ehdr>(data.data())->e_entry;
    entry_info = find_entry_segment<Elf32_Ehdr, Elf32_Phdr>(data, orig_entry);
  }

  if (!entry_info) {
    return std::unexpected("entry point is not within a loadable segment");
  }

  std::println("  ELF class: {}", is_64bit ? "64-bit" : "32-bit");
  std::println("  Original entry: {:#x} (file offset: {:#x})", orig_entry,
               entry_info->file_offset);
  std::println("  Available space at entry: {} bytes",
               entry_info->available_space);
  // Round up for 16-byte alignment
  constexpr size_t kStubAlignment = 16;
  const size_t padded_size =
      (stub.size() + kStubAlignment - 1) & ~(kStubAlignment - 1);

  std::println("  Stub size: {} bytes (padded to {})", stub.size(),
               padded_size);

  if (padded_size > entry_info->available_space) {
    return std::unexpected(std::format(
        "not enough space at entry point ({} bytes needed, {} available)",
        padded_size, entry_info->available_space));
  }

  if (dry_run) {
    std::println("  [dry-run] Would patch binary");
    return {};
  }

  // Save original bytes for config file
  const auto file_offset = entry_info->file_offset;
  if (file_offset + padded_size > data.size()) {
    return std::unexpected("entry point region extends past end of file");
  }
  std::vector<uint8_t> orig_bytes(
      data.begin() + static_cast<std::ptrdiff_t>(file_offset),
      data.begin() + static_cast<std::ptrdiff_t>(file_offset + padded_size));

  // Write config file
  auto config_path = binary_path.parent_path() /
                     ("." + binary_path.filename().string() + ".wrapbuddy");

  if (auto err = write_config_file(config_path, is_64bit, orig_entry,
                                   padded_size, interp_path, rpath, orig_bytes);
      !err) {
    return std::unexpected(err.error());
  }
  std::println("  Wrote config to {}", config_path.string());

  // Get mutable view for in-place patching
  auto mutable_data = mem.mutable_data();

  // Overwrite entry point with stub (padded)
  std::ranges::copy(stub, mutable_data.begin() +
                              static_cast<std::ptrdiff_t>(file_offset));
  std::ranges::fill(mutable_data.begin() +
                        static_cast<std::ptrdiff_t>(file_offset + stub.size()),
                    mutable_data.begin() +
                        static_cast<std::ptrdiff_t>(file_offset + padded_size),
                    uint8_t{0});
  std::println("  Overwrote {} bytes at entry point", padded_size);

  // Convert PT_INTERP to PT_NULL
  std::optional<uint64_t> interp_offset;
  if (is_64bit) {
    interp_offset = find_interp_phdr_offset<Elf64_Ehdr, Elf64_Phdr>(data);
  } else {
    interp_offset = find_interp_phdr_offset<Elf32_Ehdr, Elf32_Phdr>(data);
  }

  if (interp_offset) {
    if (*interp_offset + sizeof(uint32_t) > mutable_data.size()) {
      return std::unexpected("PT_INTERP offset is outside file bounds");
    }
    // p_type is always first field and always 4 bytes
    *start_lifetime_as<uint32_t>(mutable_data.subspan(*interp_offset).data()) =
        PT_NULL;
    std::println("  Converted PT_INTERP to PT_NULL");
  }

  // MappedMemory destructor calls munmap; kernel flushes MAP_SHARED pages
  return {};
}

} // namespace wrap_buddy
